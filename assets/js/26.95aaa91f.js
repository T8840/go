(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{433:function(n,i,o){"use strict";o.r(i);var a=o(2),t=Object(a.a)({},(function(){var n=this,i=n._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h2",{attrs:{id:"go-语言中的异常-panic定义"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#go-语言中的异常-panic定义"}},[n._v("#")]),n._v(" Go 语言中的异常：panic定义")]),n._v(" "),i("p",[n._v("不同编程语言表示异常（Exception）这个概念的语法都不相同。在 Go 语言中，异常这个概念由 panic 表示。"),i("br"),n._v("\npanic 指的是 Go 程序在运行时出现的一个异常情况。如果异常出现了，但没有被捕获并恢复，Go 程序的执行就会被终止，即便出现异常的位置不在主 Goroutine 中也会这样。\n在 Go 中，panic 主要有两类来源:")]),n._v(" "),i("ul",[i("li",[n._v("一类是来自 Go 运行时")]),n._v(" "),i("li",[n._v("另一类则是 Go 开发人员通过 panic 函数主动触发的。")])]),n._v(" "),i("p",[n._v("无论是哪种，一旦 panic 被触发，后续 Go 程序的执行过程都是一样的，这个过程被 Go 语言称为 panicking。"),i("br"),n._v("\nGo 官方文档以手工调用 panic 函数触发 panic 为例，对 panicking 这个过程进行了诠释："),i("br"),n._v("\n当函数 F 调用 panic 函数时，函数 F 的执行将停止。不过，函数 F 中已进行求值的 deferred 函数都会得到正常执行，执行完这些 deferred 函数后，函数 F 才会把控制权返还给其调用者。对于函数 F 的调用者而言，函数 F 之后的行为就如同调用者调用的函数是 panic 一样，该panicking过程将继续在栈上进行下去，直到当前 Goroutine 中的所有函数都返回为止，然后 Go 程序将崩溃退出。")]),n._v(" "),i("p",[n._v("Go 也提供了捕捉 panic 并恢复程序正常执行秩序的方法，我们可以通过 recover 函数来实现这一点")])])}),[],!1,null,null,null);i.default=t.exports}}]);