(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{424:function(o,d,t){"use strict";t.r(d);var e=t(2),l=Object(e.a)({},(function(){var o=this,d=o._self._c;return d("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[d("p",[o._v("Go module 构建模式是在 Go 1.11 版本正式引入的，为的是彻底解决 Go 项目复杂版本依赖的问题，在 Go 1.16 版本中，Go module 已经成为了 Go 默认的包依赖管理机制和 Go 源码构建机制。\nGo Module 的核心是一个名为 go.mod 的文件，在这个文件中存储了这个 module 对第三方依赖的全部信息。")]),o._v(" "),d("p",[o._v("添加 go.mod 文件命令：$go mod init")]),o._v(" "),d("p",[o._v("go mod init 命令的执行结果是在当前目录下生成了一个 go.mod 文件")]),o._v(" "),d("p",[o._v("其实，一个 module 就是一个包的集合，这些包和 module 一起打版本、发布和分发。\ngo.mod 所在的目录被我们称为它声明的 module 的根目录。不过呢，这个时候的 go.mod 文件内容还比较简单，第一行内容是用于声明 module 路径（module path）的。而且，module 隐含了一个命名空间的概念，module 下每个包的导入路径都是由 module path 和包所在子目录的名字结合在一起构成。比如，如果 hellomodule 下有子目录 pkg/pkg1，那么 pkg1 下面的包的导入路径就是由 module path（github.com/bigwhite/hellomodule）和包所在子目录的名字（pkg/pkg1）结合而成，也就是 github.com/bigwhite/hellomodule/pkg/pkg1。")]),o._v(" "),d("p",[o._v("另外，go.mod 的最后一行是一个 Go 版本指示符，用于表示这个 module 是在某个特定的 Go 版本的 module 语义的基础上编写的")]),o._v(" "),d("h3",{attrs:{id:"go-mod-tidy-命令"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#go-mod-tidy-命令"}},[o._v("#")]),o._v(" go mod tidy 命令")]),o._v(" "),d("p",[o._v("程序中引入了第三方库如果找不到的情况下，构建会有提示\n除了按提示手动添加外，我们可以使用 go mod tidy 命令，让 Go 工具自动添加\ngo mod tidy 执行后，我们 go.mod 的最新内容会添加第三方库")])])}),[],!1,null,null,null);d.default=l.exports}}]);